// TODO(pts): Add reading of floating point types.
// TODO(pts): Implement write_hex etc.
// TODO(pts): wrap(stdin) instead of `FileWrapper(stdin) >> stdin'.
// TODO(pts): Move literal, dec etc. to a namespace.
// TODO(pts): Check what code is generated by `gcc -O2' and reason why it is
// fast.

#ifndef R_SHIFTIN_H
#define R_SHIFTIN_H 1

#ifndef __cplusplus
#error This is a C++ header.
#endif

#include "r_endl.h"
#include "r_filewrapper.h"
#include "r_sinouterr.h"
#include "r_status.h"
#include "r_tfilewrapper.h"
#include "r_typetuple.h"

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <string>

// TODO(pts): Make input parsing more generic, i.e. make it work on
// std::string. This is a lot of work and can lead to code duplication,
// because we want to make the FILE* path fast.

// For eGlibc, math.h defines this, for uClibc, it doesn't.
// #define NAN (__builtin_nanf (""))

Status read_word(FILE *f, std::string *out);
std::string read_word(FILE *f);  // With error handling.

// Ignores optional whitespace in front of the number.
Status read_dec(FILE *f, unsigned nbytes, int64_t *out);
Status read_dec(FILE *f, unsigned nbytes, uint64_t *out);
Status read_dec(FILE *f, unsigned nbytes, int32_t *out);
Status read_dec(FILE *f, unsigned nbytes, uint32_t *out);

// Helper class.
class DecReader {
 public:
  inline explicit DecReader(FILE *f): f_(f) {}
  inline operator int8_t() {
    int64_t i64; read_dec(f_, 1, &i64); return i64;
  }
  inline operator int16_t() {
    int64_t i64; read_dec(f_, 2, &i64); return i64;
  }
  inline operator int32_t() {
    int64_t i64; read_dec(f_, 4, &i64); return i64;
  }
  inline operator int64_t() {
    int64_t i64; read_dec(f_, 8, &i64); return i64;
  }
  inline operator uint8_t() {
    uint64_t u64; read_dec(f_, 1, &u64); return u64;
  }
  inline operator uint16_t() {
    uint64_t u64; read_dec(f_, 2, &u64); return u64;
  }
  inline operator uint32_t() {
    uint64_t u64; read_dec(f_, 4, &u64); return u64;
  }
  inline operator uint64_t() {
    uint64_t u64; read_dec(f_, 8, &u64); return u64;
  }
 private:
  FILE *f_;
};

// Typical usage: int64_t i = read_dec(stdin);
// Number not red if result is not saved.
static inline DecReader read_dec(FILE *f) { return DecReader(f); }

template<unsigned N>class TIntegerSizeReader {};
template<>struct TIntegerSizeReader<1> {
  typedef uint8_t unsigned_type;
  typedef int8_t    signed_type;
  // TODO(pts): Probably handle Status in the .cc file, and use void here.
  static inline void t_read_dec(FILE *f, unsigned_type *out) {
    uint32_t u32; read_dec(f, 1, &u32); *out = u32;
  }
  static inline void t_read_dec(FILE *f, signed_type *out) {
    int32_t  i32; read_dec(f, 1, &i32); *out = i32;
  }
};

template<>struct TIntegerSizeReader<2> {
  typedef uint16_t unsigned_type;
  typedef int16_t    signed_type;
  static inline void t_read_dec(FILE *f, unsigned_type *out) {
    uint32_t u32; read_dec(f, 2, &u32); *out = u32;
  }
  static inline void t_read_dec(FILE *f, signed_type *out) {
    int32_t  i32; read_dec(f, 2, &i32); *out = i32;
  }
};

template<>struct TIntegerSizeReader<4> {
  typedef uint32_t unsigned_type;
  typedef int32_t    signed_type;
  static inline void t_read_dec(FILE *f, unsigned_type *out) {
    uint32_t u32; read_dec(f, 4, &u32); *out = u32;
  }
  static inline void t_read_dec(FILE *f, signed_type *out) {
    int32_t  i32; read_dec(f, 4, &i32); *out = i32;
  }
};

template<>struct TIntegerSizeReader<8> {
  typedef uint64_t unsigned_type;
  typedef int64_t    signed_type;
  static inline void t_read_dec(FILE *f, unsigned_type *out) {
    uint64_t u64; read_dec(f, 8, &u64); *out = u64;
  }
  static inline void t_read_dec(FILE *f, signed_type *out) {
    int64_t  i64; read_dec(f, 8, &i64); *out = i64;
  }
};

template<class T>class TIntegerReader {};
template<>struct TIntegerReader<unsigned char> {
  typedef TIntegerSizeReader<sizeof(signed char)>::unsigned_type int_type;
};
template<>struct TIntegerReader<unsigned short> {
  typedef TIntegerSizeReader<sizeof(signed short)>::unsigned_type int_type;
};
template<>struct TIntegerReader<unsigned int> {
  typedef TIntegerSizeReader<sizeof(signed int)>::unsigned_type int_type;
};
template<>struct TIntegerReader<unsigned long> {
  typedef TIntegerSizeReader<sizeof(signed long)>::unsigned_type int_type;
};
template<>struct TIntegerReader<unsigned long long> {
  typedef TIntegerSizeReader<sizeof(signed long long)>::unsigned_type int_type;
};
template<>struct TIntegerReader<signed char> {
  typedef TIntegerSizeReader<sizeof(signed char)>::signed_type int_type;
};
template<>struct TIntegerReader<signed short> {
  typedef TIntegerSizeReader<sizeof(signed short)>::signed_type int_type;
};
template<>struct TIntegerReader<signed int> {
  typedef TIntegerSizeReader<sizeof(signed int)>::signed_type int_type;
};
template<>struct TIntegerReader<signed long> {
  typedef TIntegerSizeReader<sizeof(signed long)>::signed_type int_type;
};
template<>struct TIntegerReader<signed long long> {
  typedef TIntegerSizeReader<sizeof(signed long long)>::signed_type int_type;
};

template<class T>class DecIn {
 public:
  typedef void *read_type;
  typedef void *reader_type;
  inline explicit DecIn(T *p): p_(assume_notnull(p)) {}
  inline void read(FILE *f) const {
    TIntegerSizeReader<sizeof(T)>::t_read_dec(
        f, static_cast<typename TIntegerReader<T>::int_type*>(p_));
  };
 private:
  T *p_;
};

template<class T>static inline
typename TypePair<const FileWrapper&,
                  typename TIntegerReader<T>::int_type>::first_type
operator>>(const FileWrapper &f, T &vr) {  // T = FileWrapper.
  DecIn<T>(&vr).read(f.f);
  return f;
}

// DecIn etc. need a valid copy-constructor even if they don't copy.
template<class T>static inline
typename TypePair<DecIn<T>,
                  typename TIntegerReader<T>::int_type>::first_type
dec(T *p) { return DecIn<T>(p); }

// ---

Status read_line(FILE *f, std::string *line);

class LineIn {
 public:
  typedef void *read_type;
  typedef void *reader_type;
  inline explicit LineIn(std::string *line): line_(line) {}
  inline Status read(FILE *f) const {
    return read_line(f, line_);
  }
 private:
  std::string * const line_;
};

static inline LineIn line(std::string *line) { return LineIn(line); }

// ---

// Ignores optional whitespace in front of the number. Rejects the bool if
// followed by any of [a-zA-Z0-9_].
//
// Can't ungetc fully on error.
Status read_bool(FILE *f, bool *out);

class BoolIn {
 public:
  typedef void *read_type;
  typedef void *reader_type;
  inline explicit BoolIn(bool *p): p_(p) {}
  inline Status read(FILE *f) const {
    return read_bool(f, p_);
  }
 private:
  bool * const p_;
};

static inline BoolIn bool1(bool *p) { return BoolIn(p); }

// TODO(pts): Eliminate redundancy in such operator>> definitions.
template<class T>static inline
typename TypePair<const FileWrapper&,
                  typename TFileWrapper<T>::tag_type>::first_type
operator>>(const T &f, bool &p) {  // T = FileWrapper.
  BoolIn(&p).read(f.f);
  return f;
}

// ---

Status read_literal(FILE *f, const char *msg, uintptr_t size);

class LiteralIn {
 public:
  typedef void *read_type;
  typedef void *reader_type;
  inline LiteralIn(const char *msg, uintptr_t size): msg_(msg), size_(size) {}
  inline explicit LiteralIn(const char *msg): msg_(msg), size_(strlen(msg)) {}
  inline Status read(FILE *f) const { return read_literal(f, msg_, size_); }
 private:
  const char * const msg_;  // Owned externally.
  const uintptr_t size_;
};

template<class T>static inline
typename TypePair<const FileWrapper&,
                  typename TFileWrapper<T>::tag_type>::first_type
operator>>(const T &f, const char *in) {  // T = FileWrapper.
  LiteralIn(in).read(f.f);
  return f;
}

static inline LiteralIn literal(const char *msg) { return LiteralIn(msg); }
static inline LiteralIn literal(const char *msg, uintptr_t size) {
  return LiteralIn(msg, size);
}

// ---

Status read_literal(FILE *f, char expc);

class LiteralCharIn {
 public:
  typedef void *read_type;
  typedef void *reader_type;
  inline explicit LiteralCharIn(char c): c_(c) {}
  inline Status read(FILE *f) const { return read_literal(f, c_); }
 private:
  const char c_;
};

// This wouldn't work as a `char c' argument, it would be ambiguous with
// `char &c' below.
template<class T>static inline
typename TypePair<const FileWrapper&,
                  typename TFileWrapper<T>::tag_type>::first_type
operator>>(const T &f, const char &c) {  // T = FileWrapper.
  LiteralCharIn(c).read(f.f);
  return f;
}

static inline LiteralCharIn literal(char c) { return LiteralCharIn(c); }

Status read_char(FILE *f, char *p);

class CharIn {
 public:
  typedef void *read_type;
  typedef void *reader_type;
  inline explicit CharIn(char *p): p_(p) {}
  inline Status read(FILE *f) const { return read_char(f, p_); }
 private:
  char *p_;
};

template<class T>static inline
typename TypePair<const FileWrapper&,
                  typename TFileWrapper<T>::tag_type>::first_type
operator>>(const T &f, char &c) {  // T = FileWrapper.
  CharIn(&c).read(f.f);
  return f;
}

static inline CharIn char1(char &c) { return CharIn(&c); }

// ---

// Check that next character is not a whitespace.
Status peek_nows(FILE *f);

// No read_type.
class NowsIn { public: typedef void *reader_type; };
extern NowsIn nows;

template<class T>static inline
typename TypePair<const FileWrapper&,
                  typename TFileWrapper<T>::tag_type>::first_type
operator>>(const T &f, NowsIn) {  // T = FileWrapper.
  peek_nows(f.f);
  return f;
}

// ---

// Check that next character is not a whitespace.
Status peek_eof(FILE *f);

// No read_type.
class EofIn { public: typedef void *reader_type; };
extern EofIn eof;

template<class T>static inline
typename TypePair<const FileWrapper&,
                  typename TFileWrapper<T>::tag_type>::first_type
operator>>(const T &f, EofIn) {  // T = FileWrapper.
  peek_eof(f.f);
  return f;
}

// ---

// Not reader_type, but read_type.
template<class V>static inline
typename TypePair<FileWrapper, typename V::read_type>::first_type
operator>>(const FileWrapper &f, const V &v) {
  v.read(f.f);
  return f;
}

// --- Starting the operator>> chain.

template<class S, class V>static inline
typename TypePair<FileWrapper, typename TStdStream<S>::tag_type>::first_type
operator>>(const S &s, const V &v) {
  FileWrapper fo(s);
  fo >> v;
  return fo;
}
template<class S, class V>static inline
typename TypePair<FileWrapper, typename TStdStream<S>::tag_type>::first_type
operator>>(const S &s, V &v) {
  FileWrapper fo(s);
  fo >> v;
  return fo;
}

// Using SFINAE (V::reader_type) to prevent the error of having neither args of
// operator>> a user-defined type.
template<class V>static inline
typename TypePair<FileWrapper, typename V::reader_type>::first_type
operator>>(FILE *f, const V &v) {
  FileWrapper fo(f);
  fo >> v;
  return fo;
}

// --- Reading from FileObj.

class FileObj;  // A forward-declaration is good enough.
template<class T>class TFileObj {};
template<>struct TFileObj<FileObj> { typedef void *tag_type; };

// We use TFileObj just to make it work with FileObj forward-declared.
template<class T, class V>static inline
typename TypePair<FileWrapper, typename TFileObj<T>::tag_type>::first_type
operator>>(const T &f, const V &v) {
  FileWrapper fo(f.f());
  fo >> v;
  return fo;
}

template<class T, class V>static inline
typename TypePair<FileWrapper, typename TFileObj<T>::tag_type>::first_type
operator>>(const T &f, V &v) {
  FileWrapper fo(f.f());
  fo >> v;
  return fo;
}

#endif  // R_SHIFTIN_H
